/*
 * PAAS平台中央认证和授权系统
 * 更多信息请联系基础框架团队
 *
 * OpenAPI spec version: 1.0.2
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.ppdai.pauth.client.api;

import com.ppdai.pauth.client.ApiException;
import com.ppdai.pauth.client.model.AuthCodeVO;
import com.ppdai.pauth.client.model.ClientVO;
import com.ppdai.pauth.client.model.OAuth2AccessToken;
import com.ppdai.pauth.client.model.ValidityVO;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.Ignore;

import java.nio.charset.Charset;
import java.util.Base64;

/**
 * API tests for OAuth2EndpointApi
 */
@Ignore
public class OAuth2EndpointApiTest {

    private final OAuth2EndpointApi api = new OAuth2EndpointApi();


    @Before
    public void init() {
        api.getApiClient().setBasePath("http://localhost");
    }

    /**
     * OAuth2授权点
     * <p/>
     * 授权点颁发authorization code
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void authorizeUsingPOSTTest() throws ApiException {
        ClientVO clientVO = null;
        AuthCodeVO response = api.authorizeUsingPOST(clientVO);
        // TODO: test validations
    }

    /**
     * OAuth2令牌检查点
     * <p/>
     * 检查令牌
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void introspectTokenUsingPOSTTest() throws ApiException {
        String token = "invalid_token";
        ValidityVO validityVO = api.introspectTokenUsingPOST(token);
        Assert.assertEquals("检查出Token是非法的", validityVO.getIsValid(), Boolean.FALSE);
    }

    /**
     * OAuth2令牌颁发点
     * <p/>
     * 颁发令牌access/refresh token
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void issueTokenUsingPOST1Test() throws ApiException {
        String grantType = "AUTHORIZATION_CODE";

        // 配置注册的测试client id/secret
        String clientId = "demo";
        String clientSecret = "8n5UxF";
        String auth = String.format("%s:%s", clientId, clientSecret);
        String encodedAuth = Base64.getEncoder().encodeToString(auth.getBytes(Charset.forName("US-ASCII")));
        String authorization = "Basic " + encodedAuth;

        String redirectUri = null;
        String refreshToken = null;
        String username = null;
        String password = null;

        OAuth2AccessToken accessToken = null;

        // 使用非法授权码获取Token
        String code1 = "invalid_code";
        try {
            accessToken = api.issueTokenUsingPOST(grantType, authorization, code1, redirectUri, refreshToken, username, password);
        } catch (ApiException e) {
            Assert.assertNull("非法授权获取Token失败", accessToken);
        }

        // 使用合法授权码获取Token
        String code2 = "E4A0qw";
        accessToken = api.issueTokenUsingPOST(grantType, authorization, code2, redirectUri, refreshToken, username, password);
        Assert.assertNotNull("非法授权获取Token失败", accessToken);

    }

    /**
     * OAuth2令牌吊销点
     * <p/>
     * 吊销令牌
     *
     * @throws ApiException if the Api call fails
     */
    @Test
    public void revokeTokenUsingPOSTTest() throws ApiException {
        String token = "invalid_token";
        String authorization = null;
        Boolean result = api.revokeTokenUsingPOST(token, authorization);
        Assert.assertEquals("对无效的token注销失败", result, Boolean.FALSE);
    }

}
